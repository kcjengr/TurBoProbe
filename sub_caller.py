#!/usr/bin/env python
# coding: utf-8

#   Copyright (c) 2018 Kurt Jacobson
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with This program.  If not, see <http://www.gnu.org/licenses/>.

import os       # For file path manipulation
import linuxcnc # For commanding linuxcnc

# These are needed for the GUI
from PyQt5 import uic, QtWidgets

# Change this path to match [RS274NGC] SUBROUTINE_PATH given in the INI
SUBROUTINE_PATH = '/home/kurt/linuxcnc/nc_files/subroutines'

# Create an instance of the LinuxCNC command object. We use this for setting
# linuxcnc modes and sending MDI commands to call the subs
CMD = linuxcnc.command()

class SubCaller(QtWidgets.QMainWindow):

    def __init__(self):
        super(SubCaller, self).__init__()

        # This loads the GUI from the `probe_tester.ui` file. This file
        # contains an XML description of the UI layout is generated by a
        # graphical GUI designer, which makes it very easy to prototype UIs.
        uic.loadUi("sub_caller.ui", self)


        # This loops thru all the files in the SUBROUTINE_PATH directory
        # and adds them to the combo box so the they can be selected.
        for filename in os.listdir(SUBROUTINE_PATH):

            # All the indented code below is run for each filename

            # Right now the filename variable contains the name of the sub file
            #   Ex: 'probe.ngc'

            # This splits the file name up into two parts, the name
            # and the extension, and stores them in a list.
            #   Ex: ['probe', 'ngc']
            filename_and_ext = os.path.splitext(filename)

            # All we need to call the sub is the filename part, we can get
            # that by taking the first element of the list like this:
             # Ex. 'probe'
            subname = filename_and_ext[0]

            # Finally, add an item to the combobox with the display text being
            # the filename and the data being the subname
            self.subComboBox.addItem(filename, subname)


        # When a button is interacted with it emits a signal which we can
        # connect to a method. In this case we want to connect the `clicked`
        # signal of the 'Call Sub' button to our callSub method.
        self.callSubButton.clicked.connect(self.callSub)


    def callSub(self):
        # this method is called when the Call Sub button is clicked

        # When we added the items to the combobox we set the data to
        # the subname. We retrieve the subname of the currently selected
        # item like this:
        subname = self.subComboBox.currentData()

        # Our getArgs method returns a string of text with the argument
        # from the input boxes.
        #   Ex. "[1.24] [.002] [0]" ...
        arg_str =  self.getArgs()

        # This builds the actual command string to sent to the LinuxCNC MDI.
        # The curly braces are replaced with the text passed to the format method
        #   Ex: "o<probe> [1.24] [.002] [0]"
        cmd_str = "o<{}> call {}".format(subname, arg_str)

        # Print the command to the terminal so the user can see what is happening
        print "Calling MDI command: ", cmd_str

        # Set the LinuxCNC mode to MDI
        CMD.mode(linuxcnc.MODE_MDI)

        # Issue the MDI command to call the sub
        CMD.mdi(cmd_str)


    def getArgs(self):
        # This method gets the input args form the input boxes and formats them
        # into a string to use when calling the sub

        # In the UI file I named the arg entries 'argEntry_1', 'argEntry_2' ...
        # We could get the text entered in each of the entries like this:
        #   arg_value = self.argEntry_1.text()

        # but we would have to do that five times, once for each entry box
        # I am lazy, so I chose to loop thru instead

        # Define an empty list so hold the args
        args = []

        # Loop thru all the input boxes.
        for arg_num in range(1, 5):

            # We can use getattr to get an item from it's string name
            entry = getattr(self, 'argEntry_{}'.format(arg_num))

            # then get the text entered in the entry
            arg_value = entry.text()

            # if no text was entered in the entry, we want to ignore it.
            # To so this we compare arg_value to an empty string the is-not-equal
            # comparison (!=)
            if arg_value != '':
                # Since arg_value is not equal to an empty string, add it
                # to the end of our list of arguments
                # we also format it with surrounded by square brackets because
                # that is the format args are passed to a sub with
                args.append('[{}]'.format(arg_value))

        # OK, at this point we have looped thru all the entry boxes and have
        # a list of the args formated as strings. Assuming only the first three
        # entries had anything in them it probably looks something like this:
        #   ['[1.23]', '[.75]', '[0]']

        # Problem is that we sting of args, not a list. We can join each element
        # of the list together with a space between them using the join command
        # This should now look like this:
        #   "[1.23] [.75] [0]"
        arg_str = ' '.join(args)

        # That is just what we need for the args to pass with the sub call
        # so return the value
        return arg_str


if __name__ == '__main__':
    import sys
    app = QtWidgets.QApplication(sys.argv)

    sub_caller = SubCaller()
    sub_caller.show()

    sys.exit(app.exec_())
